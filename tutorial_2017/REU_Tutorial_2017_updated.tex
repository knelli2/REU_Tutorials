%% LyX 1.6.5 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{graphicx}
\graphicspath{{img/}}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{babel,amsmath,amssymb,amsthm,wrapfig,xifthen,placeins,verbatim,xparse,enumitem}

\newcommand{\cd}[1]{\texttt{#1}}
\newcommand{\image}[3][]{ %\image[(optional)caption]{scale (0-1)}{image_name.jpg}
	\FloatBarrier
	\begin{figure}[!htbp]
		\includegraphics[scale=#2]{#3}
		\centering
		\ifthenelse{\isempty{#1}}{}{\caption{#1}}
	\end{figure}
	\FloatBarrier
}






\begin{document}

\title{REU Tutorial 2019}


\author{Abid Khan, Sean Connelly, Cunwei Fan, and Patchara Wongsutthikoson\\
	Edited: Eric Connelly, Imran Sultan, Minh Nguyen}




\maketitle
\clearpage
\section{Intoduction}
This tutorial will familiarize you with the basic software and methods used in this REU.
It is not comprehensive, but upon completion, you should be able to contribute effectively to the group.
Previous incoming students have typically completed this tutorial in a few weeks.


\section{Accounts and Keys}
One of the senior members will join you to get this section done.
You can take your time, but getting these done quickly will make your life easier.
    \begin{itemize}
        \item Get keys for Loomis and the REU office.
        \item Talk to Rebecca Wiltfong (rwiltfon@illinois.edu, 290L LLP) about permissions for the REU webpage.
	\item Get your Blue Waters Token and have the account activated. You should have gotten an email about it. Talk to Milton Ruiz (setisam@gmail.com) if you come across troubles.
    \end{itemize}

\section{Linux}
    This group uses Linux exclusively. Over the years, you will learn to use it and eventually prefer it over any other operating system. One of the most important and powerful tools you will need to master on Linux is the \textbf{terminal}. How to use terminal will become clear as you work with it. A good way to start is by familiarizing yourselves with the following basic commands (i.e. by googling, etc.): \cd{cd, ls, mkdir, touch, cp, rm} (be \textit{very careful} with this one). A quick way to learn what a command does is to type \cd{man \textbf{commandname}} into the terminal. After that, you can look at some more useful commands below.
    \subsection{Gereral commands}
    \begin{description}
	\item[\cd{grep}]	This command outputs items that match your input pattern strings.
			It is very useful in finding files and filter the output of another command
			when used with pipe (|).
			eg: \cd{grep 1200 foo.txt} will output the lines that has "1200" in file foo.txt.
			
        \item[\cd{pipe (|)}] This command makes compound commands available, allowing you to perform more complicated operations in one command line. It will feed the output of previous command as the input for the next one. e.g: \cd{ls | grep foo}, this use the output of ls command as the input for grep command. This command line will display the items in current directory that has pattern string "foo" in it.

	\item[\cd{redirect (>)}] This command will redirect the output display to another proper place (we usually use this to output into a text file.) e.g \cd{echo hello world > new.txt} will modify the file "new.txt" (or make a new file "new.txt", if it doesn't exist) to have "hello world" as its content. Note that \cd{>} erases the file before writing, while \cd{>{}>} appends to it.

        \item[\cd{sort}] 	What do you think it does?
        
        \item[\cd{uniq}]	Delete \textit{consecutive} duplicate lines of a file. See \cd{awk} for how to delete \textit{non-consecutive} duplicate lines.

	\item[\cd{scp}] 	At times we will be needing to send files or data to each other for collaboration. How do we do that? EMAIL?! Where's the fun in that? To send a file from one machine to another type \\
			\cd{scp filename colten1@machine.physics.illinois.edu:/home/colten1/Desktop}, \\
			where instead of ``machine'' put in the name of the computer you want to send it to. Also you can retrieve a file from another machine using the same command:\\
			\cd{scp colten1@machine.physics.illinois.edu:/full/path/to/file /path/to/folder} \\
			If you want to transfer a directory instead, put an \cd{-r} after scp

	\item[scripting] Bash supports a few simple common functions like for loop and if condition. These function allow you to write more complicated scripts that can perform a series of operations. I'm not going to write down the usage of those function, as most of them you should easily find documentations on google whenever you need them. The only one thing I want mention is that in bash scripts, when you want to refer to a variable you defined earlier, put a dollar sign (\cd{\$}) in the front. eg. \cd{var=1; echo \$var}
			
	%\item[Vim]	Get familiar with a terminal-based text editor, such as Vim (some alternatives are Emacs and nano). This will come in very handy for quickly reading/editing files. Vim is quite advanced and there's no need to understand everything (\textit{yet}), but do learn the basics, such as editing and saving files (and exiting out of Vim, of course).
			
			
	\item[\cd{awk} (optional)] 	Technically a programming language, but useful for editing text files. Ubiquitous in Unix-like systems. This command allows you to perform data extraction based on patterns. A few simple ways of using it will be \cd{awk `{print \$2}'} (print 2nd column of a file), and \cd{awk `!seen[\$0]++'} (remove non-consecutive duplicate lines) \\ Refer to \cd{http://www.pement.org/awk/awk1line.txt}
       		   	
	\item[\cd{sed} (optional)] 	Short for `stream editor'. This is a very powerful string editing tool which allows you to perform text deleting and modifying operations. \\ The official documentation is at \cd{http://sed.sourceforge.net/sed1line.txt}, but if you want a guide, I'd recommend looking here: \cd{http://www.grymoire.com/Unix/Sed.html}
    \end{description}
    Now you should be able to manage your files and manipulate them in a basic way.
	
	\subsection{Vim}
		\paragraph{} On Blue Waters, because we are remote accessing it, the only text editor we will be able to use is Vim. So learn it, live it, love it becasue you will be working with it all the time. To open a file with vim, do \cd{vim <filename>} (note that this will create a new file if \cd{<filename>} doesn't exist). There are three different modes to Vim:
		\begin{description}[leftmargin=!,labelwidth=\widthof{\bf Command mode}]
			\item[Command mode] Used to navigate the file and execute commands that affect the file as a whole. This is the mode you start in when you open a file. To get to this mode, press Esc (maybe many times).
			\item[Insert mode] Used to type text in your file. To get to this mode, press a.
			\item[Replace mode] Similar to Insert mode, but makes you overwrite existing text as you type. To get to this mode, press R.
		\end{description}
		\par To help expedite the learning process here are a few helpful commands in \textbf{Command mode}:
		\begin{description}[leftmargin=!,labelwidth=1.2in]%\widthof{\cd{<num><command>}}]
			%\item[\cd{vim <filename>}] This is how you open and make a file in terminal. This will create a new file if \cd{filename} doesn't exist.
			\item[\cd{:w}] To save (or write) the buffer to file.
			\item[\cd{:q}] To quit out of a file (without saving). Adding `\cd{!}' at the end (i.e \cd{:q!}) will force quit without saving.
			\item[\cd{:x {\rm or} :wq}] To save and then quit the file.
			\item[\cd{/<txt>}] To search the file for \cd{<txt>}. This is case sensitive. To get to the next (previous) search result, simply press \cd{n} (\cd{N}).
		\item[\cd{:n {\rm and} :N}] If you have multiple files open, :n goes to the next file, and :N goes to the previous file. If you're on the last file, :n will not work, so you will have to exit the files.
			\item[\cd{gg}] To go to the beginning of the file.
			\item[\cd{G}] To go to the end of the file.
			\item[\cd{0}] To go the the beginning of the line.
			\item[\cd{\$}] To go the the end of the line.
			\item[\cd{dd}] To delete the line the cursor is on. This will also copy the line for pasting.
			\item[\cd{yy}] To copy everything on the line after the cursor.
			\item[\cd{p}] To paste the text you just copied or deleted on the line below your cursor.
			\item[\cd{u}] To undo the last command.
			\item[\cd{Ctrl+r}] To redo the command.
			\item[\cd{r}] To replace the character your cursor is on. This takes an input, i.e pressing \cd{re} will replace the character with `e'
			\item[\cd{x}] To delete the character your cursor is on.
			\item[\cd{<num><command>}] To execute \cd{<command>}, \cd{<num>} times, i.e \cd{5dd} will delete 5 lines.
		\end{description}

Now you should be able to do most of the basic stuffs completely within terminal.

\subsection{Exercises}
    Don't spend too much time trying to work these out yourselves; if you get stuck, feel free to use Google to whenever you need to. These are mainly designed for pedantic purposes.
    \begin{enumerate}
	\item Count the number of files in a folder. 
	\item Remove the extension part of the file name. eg. "foo.txt" $\rightarrow$ "foo".
	\item Use the \cd{tail} and \cd{head} command to remove the first and last line of a text file. After that, try using sed.
	\item Use \cd{grep} command to delete all the lines in a text file that contains a specific pattern (say "NaN"). \textit{Hint: \cd{-v}} (While \cd{sed} can be used, it is much slower for larger files).
	\item Use \cd{sort} command to sort a text file based on the value in the second column in each line. Assume your text file has multiple rows and columns. \textit{Hint: \cd{-k, -n}}
    \end{enumerate}
%	\item write a bash script that goes through a file and find the max and
%	min value (assume max < 10000 and min > 0) of the data in the
%	third column (hint: awk)
%	\item do the same thing in the previous exercise, but this time you are
%	provided with a series of files (eg. "foo1.txt", "foo2.txt"...), find the
%	max and min over all these files.
%	\item You are given a series of files that are named in numerical order. Write
%	a bash scripts that separate these files into two folders such that odd-
%	numbered files and even-numbered files are separated. Make sure in
%	new folders, the files are still in correct order. (This script is used to
%	separate the 3D images we filmed for left eye and right eye).


\section{Basic Imaging}
The group presently uses VisIt (\cd{https://wci.llnl.gov/codes/visit/}) to render movies and still images. This software is installed on all REU machines, as well as Blue Waters. You are encouraged to read the manuals at:\\
\cd{https://wci.llnl.gov/codes/visit/manuals.html}\\
To begin using VisIt, simply type `visit' into a terminal of your choice.

\subsection{Exercises:}
    \begin{enumerate}
%        \item Familiarize yourself with the VTK file format. 
%            Read this. \\
%            \cd{http://www.vtk.org/VTK/img/file-formats.pdf}\\
%			The purpose of this is \textit{not} to become an expert in VTK. We rarely use the VTK file format, if ever. Instead, this is an exercise in learning something you (presumably) have never seen yourself and touching upon the way data may be stored in large scale projects like ours. Try to get comfortable with it, but don't worry if you don't totally understand it.
        \item Useful to us is the \cd{.3d} data format. The \cd{.3d} data format just contains four columns of the form \cd{x y z scalar}. Create a \cd{.3d} datafile of the scalar field $d = x^2 y^3/z^5$ and visualize it in VisIt using a custom colormaps that you make. Be creative and try to explore VisIt's features.
        \item Next, create a sphere, using Python, C++ or whatever language you want, with radius 2 at a distance 8 from the origin, and visualize it. \textit{Hint: the Delaunay operator creates a surface from a set of points.}\footnote{The Delaunay operator is not enabled in VisIt by default. You may need to turn it on by going to \textit{Options} > \textit{Plugin manager}, and make sure to save settings. You'll have to restart  VisIt.} Display the sphere in VisIt.
	\item You will be given an HDF5 file representing a vector field. If you don't have it, ask one of the seniors in the group. Visualize the vector field contained in this HDF5 file with a streamline plot. Create seed particles for streamlines and visualize these as well.
    \end{enumerate}



\section{Advanced Imaging}
The goal of this section is to get you to use the skills and knowledge you have acquired so far. You will do this by visualizing the magnetic field of a current loop in two different ways. Upon successful completion of this exercise you should have the necessary background to start learning the daily work of the group. 

\subsection{Excercise Instuctions:}
\begin{enumerate}
    \item First you should generate the $x$, $y$,and $z$ components of the magnetic field of a loop of current. The loop has a current of 4A and an area of $4\pi m^2$ . Generate this data for an area of 12m$\times$12m$\times$12m. The resolution choice is up to you. However, you will be integrating over this data so choose wisely. Useful equations can be found:
        \begin{itemize}
            \item \verb|https://en.wikipedia.org/wiki/Magnetic_moment|
            \item \verb|https://en.wikipedia.org/wiki/Biot-Savart\_law|
            \item Griffiths EM textbook.
        \end{itemize}
    \item Now that you have a data file, visualize the field in VisIt.
    \item Following that, generate a data file containing a collection of positions corresponding to points on the ring of current. You shall then use these points as seeding points for streamlines. 
    \item Your next task is to generate your own field lines and to visualize them in VisIt. You will use the seed points from above as starting points for each field line. For the integration, please implement the fourth order Runge-Kutta method. You can find it on Wikipedia.
    \item Compare your field lines with those generated by VisIt. Then, just play around with the seed points until you start to get a feel for them.
    \item Save a high quality image of the field and stream lines.
%    \item One you have completed all of the above steps in visit, modify the formats of your code output and create the same images using VisIt (by outputting to VTK).
\end{enumerate}hese are mainly designed for pedantic purposes



\section{Gravitational Waves}
\paragraph{}Just as how E-M waves come in two polarizations, so do gravitational waves, namely $h_{+}$ and $h_{\times}$. You will be generating movies of these two polarizations for various systems.
The data that is obtained from the post-docs to generate gravitational wave movies is called 
\cd{Psi4\_rad.mon.3}. This file contains columns of data. The first column is the time column, and the 
columns after that are coefficients $\psi_{4}^{lm}$ in the equation 
\begin{equation} 
\psi_{4}(t,r,\theta,\phi)=\sum_{l=2}^{\infty}\sum_{m=-l}^{l}\psi_{4}^{lm}(t,r)\cdot{}_{-2}Y_{lm}(\theta, \phi), \label{eq:psi4}
\end{equation}
where the $\psi_{4}^{lm}$ columns are evaluated at an extraction radius $R$.
In equation~\ref{eq:psi4}, $\psi_{4}$ is decomposed into $s = -2$ spin-weighted spherical harmonics. From
equation~\ref{eq:psi4}, we can obtain $h_{+}$ and $h_{\times}$ by
\begin{equation} 
\psi_{4}=\ddot{h}_{+} - i\ddot{h}_{\times} \label{eq:diffeq}
\end{equation}

Our code, "hplus\_hcross.cpp", takes $\psi_{4}^{lm}$, the ADM mass $M$ in code units, and the 
extraction radius $R$ in code units as inputs. It outputs 
$h_{+}$ and $h_{\times}$, from which we take and generate our movies. The code does this by 
fast Fourier transforming the equation 
\begin{equation} 
\sum_{l=2}^{\infty}\sum_{m=-l}^{l}\psi_{4}^{lm}(t,r) \cdot{}_{-2}Y_{lm}(\theta, \phi) = 
\ddot{h}_{+} - i\ddot{h}_{\times}, \label{eq:codeEq}
\end{equation}
which is just a combining of equations~\ref{eq:psi4} and~\ref{eq:diffeq}. It then does a backward 
fast Fourier transform to obtain coefficients $C_{lm}$ in the equation 
\begin{equation} 
\frac{1}{2}(h_{+}-ih_{\times})=\sum_{l, m}C_{lm}\cdot {}_{-2}Y_{lm}, \label{eq:clm}
\end{equation}
from which we can obtain $h_{+}$ and $h_{\times}$. The ${}_{-2}Y_{2,2}$ and ${}_{-2}Y_{2,-2}$ modes dominate this sum, so we can approximate $h_{+}$ and $h_{\times}$ as 
\begin{align} 
h_{+} &\approx 2 \Re\left(C_{2,2}\cdot {}_{2}Y_{2,2} + C_{2,-2}\cdot {}_{-2}Y_{2,-2}\right) \\
h_{\times} &\approx -2 \Im\left(C_{2,2}\cdot {}_{2}Y_{2,2} + C_{2,-2}\cdot {}_{-2}Y_{2,-2}\right) \label{eq:happrox}
\end{align}


\subsection{Calculating $h_{+}$ and $h_{\times}$}
\paragraph{} Zach's code is called to sum over the $_{-2}Y_{lm}$ modes and evaluate $h_{+}$ and $h_{\times}$ at a chosen $\theta$ and $\phi$. 
It is assumed that in the far zone the amplitudes of $h_{+}$ and $h_{\times}$ drop off like $\frac{1}{R}$. 
Therefore, Zach's code removes the radial dependence and gives $R\cdot h_{+}$ and $R\cdot h_{\times}$. 
The output from Zach's code when it is passed a chosen ($\theta_{i}$,$\phi_{i}$) is 
$R\cdot h_{+}^{'}(\theta_{i},\phi_{i})$ and $R\cdot h_{\times}^{'}(\theta_{i},\phi_{i})$ 
evaluated at a series of values of $\frac{t}{M}$,
each seperated from the next by some timestep $\Delta t$. \\
At a given point $(r_{j},\theta_{i},\phi_{i})$ (defined in a coordinate system with origin at the center of mass of the initial configuration) and time $t_{k}$, 
the amplitudes of $h_{+}$ and $h_{\times}$ will be
\begin{align*}
h_{+} & =\frac{h_{+}^{'}(\theta_{i},\phi_{i})(t^{'})}{r_{j}}\\
h_{\times} & =\frac{h_{\times}^{'}(\theta_{i},\phi_{i})(t^{'})}{r_{j}}\\
\end{align*}
where $h_{+}^{'}$ and $h_{\times}^{'}$ are the functions obtained from Zach's code and $t^{'}$ is the retarded time $t^{'}=t-\frac{r_{j}}{c}$ ($c$ being the speed of light, (taken to be $c=1$).
Since $t$ only comes in discrete intervals, $\Delta t$, we choose radii $r_{j}=n\Delta t$ and times $t_{k}=m\Delta t$ for integer n,m at which to evaluate the amplitude of the wave. 
This ensures that the retarded time $t^{'}=t_{k}-r_{j}=(m-n)\Delta t$ is an integer multiple of $\Delta t$ and can be evaluated with the data given by Zach's code. 
If $t^{'}$ is less than zero then the amplitude of the wave is taken to be zero, because this implies that $r_{j}>ct$ (i.e. the wave has not yet reached this radius).
\subsection{Data-Processing:} 
    \begin{enumerate} 
        \item In order to make a gravity wave movie, you will be given a number of raw Psi4 datasets in the form of Psi4.rad.mon.\#, together with black hole event horizen data and density data. 
            You may also have a diagnostic datafile that gives you the ADM mass, extraction radius etc. 
            Make sure you have all these parts before proceeding.  
        \item Next, choose which Psi4 file to work with. 
            Generally speaking, we prefer to use a larger extraction radius since waveforms generated by numerical codes at smaller radius aroud black hole are less trustworthy. 
            However, the problem is sometimes waveforms with larger extraction radius have abnormal behaviors, thus you need to check the Psi4 data yourself. 
            One way to check the data is using gnuplot. For example, you can type in a terminal: \\
            \quad gnuplot\\
            \quad plot './Psi4.rad.mon.\#' u 1:2 w l. 
        \item Due to checkpointing, the raw data has a lot of duplicated timesteps. Duplicate timesteps, and those containing a 'NaN' datum must be removed before proceding. You can try and create a script yourself however we have a convenient script called "clean\_and\_sort.bash" that will do it for you.
        \item With the sorted data, you can proceed with our main processing code: hplus\_hcross.cpp. 
            The code will read-in the raw Psi4 data in certain radius, calculate the waveforms, and output to time-series VTK files organized into numbered folders. 
        \item There are a couple of things you need to check in the code. 
            In the function Write3D, you will need to specify the ADM mass and the extraction radius for example. 
            Then you will need to specify the spatial dimensions (usually we use 150{*}150) and spatial resolution (use an odd number to avoid singularity at z=0\footnote{This may no longer be true. I don't know.}). 
            Make sure the spatial resolution is neither too low nor too high because then the final data will be unmanagably huge (just gives you an idea, 151{*}151 may works fine).  
        \item To use the code run the "run\_hphc.sh" script which should be in the root directory of abidbot. Make sure to set the params first!
    \end{enumerate}
    
\begin{comment}
%\section{Movie Settings:} 
%    \begin{enumerate} 
%        \item Load hplus as a time series data. 
%        \item Apply an arithmetic module on the waveform data. 
%            Our goal here is to get rid of waves within the extraction radius and also the waves outside certain radius in order to make our waves look like a sphere rather than a cube. 
%            One simplest way is straight cut-off: A{*}(r\textgreater{}50){*}(r\textless{}150). 
%            I personally prefer to use a more complicated ``Fermi-cutoff'' (I coined the term, refer to Fermi-distribution function), so that I can make the outter cut-off very soft.
%            Experiment different cut-offs on your own. 
%        \item Next we connect resulting data to Amira module callled Volren. 
%            Now you need to specify the range of magnitude. 
%            Go to timesteps aroud merger, check your resulting data (after Arithmetic) for maximum absolute value, then the value will be your max and min. 
%        \item Colormaps. With max and min in hand, you are ready to make a colormap on your own. Make a serious attempt before checking out our old gw colormaps. 
%        \item Fine-tuning your colormaps:save your colormap, and load it with gedit(or any other editor of your choice). You can see  4 columns of data after the header infomation. 
%            The four columns each responding to Red, Green, Blue and Alpha(opacity) channel. 
%            Write your own c++ program to fine-tune the colormap.  
%        \item Finally go to MovieMaker. 
%            We usually use resolution 640 by 480 and tiles 2 by 2. 
%    \end{enumerate}

\subsection{Subtle Points}
Notice, From equation~\ref{eq:diffeq}, we see that the second derivative of $h_{+}$ or $h_{\times}$ is $\Psi$. If we use notation $c=G=1$, we may see that mass $M$, radius $r$ and time $t$ has the same units (as $[r] = c[t]$ and $G[M]/c^2 = [r]$). Thus, we see that $\Psi_4$ has dimension as $[t]^{-2}$ instead of dimensionless. 
To deal with dimensional quantity, we usually make it dimensionless. Thus, the code "hplus\_hcross.cpp" assumes the $\Psi_4$ files it processes has no dimension. To make the $\Psi_4$ files dimensionless, we need to rescale the $\Psi_4$ with a length scale $K^{n/2}$. Where if you know polytropic equation of state,$K$ is the constant in 
\begin{equation}
P = K \rho ^{\Gamma} \text{,\quad and \quad} \Gamma = 1 +\frac{1}{n}  \label{eq: eos}
\end{equation}     
Thus, for the first column of "Psi4.mon.rad.\#" we need to divide $K^{n/2}$ and for the remaining columns we need to multiply by $(K^{n/2})^2 = K^n$. As the first column is time which has unit of length and the remaining columns are $\Psi_4$ which has units of $[r]^{-2}$.
After the "Psi4.rad.mon.\#" is rescaled to dimensionless, you can put it into the "hplus\_hcross.cpp" to generate waveforms.
(Another suggestion, you can rescale it after you sort the Psi4 file "Psi4.rad.mon.\#".) However, for pure black hole cases, we may not have polytropic gas and thus we just use $K=1$. For neutron star cases or other cases that you may need polytropic gas, please ask the post docs about the constants you want.

Another sublte point is that, if you remember, the waveforms $h_+$ and $h_{\times}$ are generated from $\Psi_4$ by backward fast Fourier transform. Also, the $\Psi_4$ for magnetic field cases may not start from $t=0$ but star from some positive $t_0$. Thus, in the backward fast Fourier transform which is some kind of integration, we may lose some information from $t=0$ to $t=t_0$. However, if the wave last for a long time, the lost information may not play a big role. If the wave last for very short time, you may ask the post docs or Ph.Ds for the data between $t=0$ to $t=t_0$. Thus, to determine whether the part of information is crucial, you may want to generate the 1D waveform first and then check whether the plot is wave like and makes sense. If everything is fine, you can keep going; but if the 1D plot does not make sense, you may need the lost part of information. (But usually, the given file has enough information. If you find your 1D plot problematic, please check first whether everything is scaled correctly and sorted finely.)
\end{comment}

	\subsection{Making gravity wave images}
	\paragraph{} Time to actually make the gravity wave images! To start you will need a few scripts which should be abidbot: "runGW.sh", "/bin/gw\_code/GW\_up.py", and "/bin/gw\_code/makeGW\_movie.pbs"
	\begin{enumerate}
		\item In "runGW.sh" you will need to change a few things.
		\begin{itemize}
			\item Choose which type of gravity wave you want to visualize (either $h_+$ or $h_x$)
			\item Choose how many VTK folders you want to run. Each folder has 25 of each kind in it and we typically do 5 frames per rank.
			\item Choose the job name (usually related to the type of gw)
			\item Choose the pbs script you want to use (almost always "/bin/gw\_code/makeGW\_movie.pbs")
			\item Choose the visit script you want to use (again almost always "/bin/gw\_code/GW\_up.py") For the gravity ways we typically just use the volume attributes that are hard coded into the file. (Don't ask me why we haven't made an xml for it yet)
		\end{itemize}

		\item Then just run the "runGW.sh" script in the root folder as ./runGW.sh and you're off to making a movie!
	\end{enumerate}

    \subsection{Superimposing density profiles}
        \paragraph{}You may be asked to create a film where the density profile is superimposed over the gravitational radiation waveform.
        Unfortunately, VisIt can only render one volume plot via raycasting.
        The following method will circumvent this limitation.
        \begin{enumerate}
            \item Film a density movie with slightly different camera settings as your GW movie. We have found that if you use the same settings, the stellar objects will appear much bigger than they actually are comapred to the gravity waves. Here is what we have found has worked:
            	
            	\begin{itemize}
            		\item Keep the up vector, normal vector, focal point, and the zoom the same
            		\item Divide the parallel scale and the near and far clipping of the density view by 10
            	\end{itemize}
            	
            	If this doesn't look perfect, play around with the zoom until it does.

            \item Next you will use our "prepare\_gw\_rho.py" script to match up the density times with the gravity wave times. We need to do this because the output frequency of the datasets is usually different. Typcially, the gravity wave data is outputed more frequently so we need to duplicate frames from the density movie so everything looks smooth.
            
            \item Once that script is run, you will have two new directories holding the aligned data. At this point, to combine the images, you will want to open gimp, go to the "filters" tab, mouse over "Python-Fu" and click console. This will open up a small python2 console inside gimp.
            
            \item Open the script "gw\_rho\_merger.py". Make sure all the paths to the folders are correct. Then simply copy the code (starting from the line with "root") into the console in gimp and hit enter twice. It will take a while to run as gimp has to open, edit, and close every single image.
        \end{enumerate}
        
        Things to note:
        \begin{itemize}
            \item The resulting images will use the time from the gravity wave data so make sure that is correct before you start making images
            \item You may need to play with the opactites in the gimp script to get a better image
		\end{itemize}

\section{Python Scripting}
    \paragraph{}VisIt can be scripted via python, which allows easy standardization of movie parameters. The scripting is relatively straightforward. Ask a senior member to provide a preexisting script, then adapt this script to automatically create a movie of the gravity wave you've been examining. Try adjusting the camera settings to zoom and rotate around the waveform.

Python Scripting: You are going to make a movie that will be filmed entirely using a python script. That means the data will be loaded, the plots will be set up, and your dataset will be iterated through time. Also the camera should move around all pretty and such. I'll have you create this script piece by piece so that its all not a giant mess.

You are going to need a time varying vector dataset. Its three sets of scalar fields that you are going to have to combine into a vector field in VisIt using expressions. Go make this.

Your first task is to open up your dataset using just the cli. Maybe there is a function that will do this for you. Maybe its called OpenDatabase(databaseName). Maybe databaseName will be set to something like \verb|/home/projects/TutorialData/myfilename_*.vtk database|. Make sure that your database has opened without errors. Now would be a good time to make a script. In your favorite text editor (\textit{cough} vim \textit{cough}), open up a new document and call it whatever you want. Make sure to add \cd{.py} to the end. At the top of your new script put "Source(/path/to/script.py)" This will help because you can't copy and paste into the cli normally because its stupid. Instead, you have to highlight what you want to copy and paste it by clicking with the middle mouse button (This magical thing you just did is a very simple copy and paste. highlighting text will copy it into a buffer, and clicking the middle mouse pastes it to where the cursor is. Learn to use this tactic, as it's going to be very handy). This helps when you need to rerun things and don't want to type a full path all the time.

Now that that's done, delete all the plots. You'll need this because otherwise if you rerun your script, you'll end up with multiple plots. Next we want to make a plot. For now we want a streamline plot.

Also make sure to add all the settings. Next you can do things like setup the settings for window saving, change the backround color to your favorite color, remove the bounding box, set your initial view angle, etc. There are functions that will do this. Usually one of them includes the words Get and Attributes. You can probably find it in the Python interface manual.

Now, you can begin coding the movie making loop. You'll want a for loop that iterates through each frame once (hint: range(GetNSteps()). For each iteraction, you'll set the timestep, make the changes that you want (i.e. add new streamline seeds, change the view angle, etc.), and call SaveWindow(). For now, just update the timestep and call SaveWindow(). With the above done, you should have a basic movie script. You can run your script in the cli using \cd{Source(/path/to/script.py)}. To make things more interesting, you are now going to add code that will update the streamline plot so that the streamline seeds will change each timestep. This is pretty important for actual movies since we often use particles that move through time as seeds. The seed points are given to us (if they are particles) or we can generate them ourselves (we have to process them into .txt files though). This time, just generate some seeds. Edit your code that you used to visualize a rotating sphere to just give a txt file with some rotating points. Or, you could make moving points in some other way. It doesn't matter too much for the purpose of this exercise. To see a good amount of streamlines, I'd make it so there are about maybe 10 points total on the sphere (or whatever), but thats just a guestimate. You can do more or less depending on how you feel it will look. You can also always go back and change it. With this data and updated code, make a new movie where the streamline seeds are updated at each timestep. Now add code to make the camera pan across your data set. Probably use something like cubicevalspline to help you with this.

With that done, you've done most of the fancy things you need to do in an
ordnary movie.


\section{Blue Waters}



\paragraph{}The size of our simulation data is on the order of terabytes. Thus it requires a mighty machine to both store that data, and parse through it quickly. This is where Blue Waters comes in. Each simulation is a couple hundred frames long, and each frame takes about 20 minutes to create. Blue Waters allows us to generate these frames in a matter of minutes, rather than days. This is done using parallel programming. Read the getting started guide on the blue waters page \verb|https://bluewaters.ncsa.illinois.edu/getting-started|.

You are now going to edit your movie script so that it can be run on Blue Waters. Hopefully by now, you guys have accounts on Blue Waters. If not you can just borrow anyone else's account for the purpose of this tutorial.

The first step is moving your data to Blue Waters. There are two ways to do this. One is to use a terminal command such as scp or rsync. The other is a program called globus online. Globus online should be used for transfering large amounts of data because that's how the BW guys want you to do it. You can use the terminal for smaller files such as scripts, seeds, and .txt files. Even though your data set is not very large, I'm going to have you transfer the data using globus online. Ask me how to do that when you get to this point. Then, when you are done with that scp or rsync the rest of your files over. Nodes on blue waters can be thought of as individual computers. There are two types of nodes found on any computing system of this type. The first is a login node. These are the nodes which you automatically ssh onto. The second are the compute nodes.

You can't log on to these nodes but you can use a command called qsub to submit jobs. The jobs are submitted to a queue and run when its your turn. The default compute node has something like 32GB of RAM split up between 16 processor cores. These nodes are all connected with a very fast ethernet connection so they can send data to each other really fast. They are also all connected to the same data on disk as well. Change your .py script so that the files you access correspond to where you data is on bw. Then go here https://bluewaters.ncsa.illinois.edu/visit and read the section on visit's command line interface and batch mode. You can use the sample .pbs file they give you. With that file in hand, call "qsub myfile.pbs" after editing the file.

You can check on your submission with "qstat -u username" (or ask one of the older guys for their \cd{$\sim$/.bashrc} file). If that works, now try and "parallelize" your code. More specifically, you want to make it so that you can split up the frame making work amongst multiple computers. For example, say your dataset has 200 timesteps. You have 4 computers. That means you'll probably want to give each computer 50 timessteps to make pictures from. Make adjustments in your code so that when given the total number of computers and the computer number (we'll call it rank), you'll successfully split up the work and output frames for you movie. In our example, we have 4 computers total. One computer will have rank 0, another will have rank 1, etc. However, don't hardcode these numbers directly. Keep them as variables which you can pass to your script. To access them in your code, use \verb|sys.argv|. If these concepts don't make sense, feel free to ask me for clarification.

\subsection{Selected Exercises:}
\begin{enumerate}
\item Log into Blue Waters using \verb|ssh -X <username>@bw.ncsa.illinois.edu|
\item Open Visit using \cd{module load visit; visit}. Check the settings to ensure that the Delaunay operator is loaded. Close VisIt.
\item Make a batch script following the recipe found online, and submit it to the blue waters job queue.
\item Bask in the glory of your life because you're using a heavenly supercomputer.
\end{enumerate}


\section{Particle Picker}
We need particles to create a seeding points for magnetic fieldlines and to create particle movies. You will get a raw data file for particle position at all time, usually named as \verb|bhns-particles.mon| or \verb|particles.mon|. Our task is to choose some useful particles, and convert the file into a format that is readable in VisIt. This can be done by using the particle picker module.
        
You will need to transfer the abid bot to your Blue Waters. This is the ultimate code that you will be working with most of the time. For now we will skip most of the features and focus on particle picker module. The module is located in \verb|/path/to/your/abid/bot/bin/particle_code/|. But there are a few steps you need to do before getting there.

    \begin{enumerate}
        \item Ask for the \verb|particles.mon| file from previous REU members. Then copy it to \\ \verb|/path/to/your/abid/bot/h5data/|. Note that you need to rename it to \verb|particles.mon| if it is named differently.
        \item Change parameters inside the file \verb|/path/to/your/abid/bot/params|. We are going to work with particle seeds, so set \verb|fields=true|, \verb|particleSeeds=true|, and \verb|updateParticleMon=true|. Other parameters will be different from case to case. Ask others if you are stuck here for too long.
        \item Now setup the parameters. First, enter \verb|params| in command line. This will save parameters that you specified in params on your current shell. Next, normally you will run the \verb|setup.sh| script to set everything. But since we are only doing particle picker, you can run abid bot partially by going into bin folder and run \verb|setup_seeds.sh|. This step will take considerably long time, usually about 1+ min per GB of your \verb|particles.mon| file. After this is done, go to \verb|/path/to/your/abid/bot/bin/particle_code/| and check \verb|dat| folder. You should have a bunch of files with the name like \verb|00012.34567000000.dat| and the name of your first file should be \verb|<firstTime>.dat|. If you get this, then cheers!, you've finished the most time consuming part of particle picker. Set \verb|updateParticleMon=false| in params to skip this part in future runs, as it is only necessary to do so once.
    \end{enumerate}

Now go to \verb|/path/to/your/abid/bot/bin/particle_code/|. There are three files involving particle picker: \verb|particlePicker.py|, \verb|particlePicker-tracer.py|, and \verb|particlePickerModule.py|. Do not edit the \verb|particlePickerModule.py| unless you know what you are doing. By all means, I encourage you to take a look inside and try to understand the module. The file you will be editing is either \verb|particlePicker.py| or \verb|particlePicker-tracer.py|. They are exactly the same except that the tracer one save files in \verb|.3d| format instead of \verb|.txt|. These script will pick particles based on your criteria. There are currently two methods to choose particles: \verb|findInVolume| and \verb|nearestNeighbor|. Details for these methods are in \verb|particlePickerModule.py|.

Your task for this part is to make a simple particle tracer movie (only particle, without density and fieldlines). If you don't know what it is, please see \\ \verb|http://research.physics.illinois.edu/cta/movies/NSNS_high_res/particles_ext.html|. You will have to edit \verb|particlePicker-tracer.py|, set \verb|particleTracer=true| in params, run \verb|params|, and run \verb|setup_seeds.sh|. If it is working correctly, you will get \verb|trace*.3d| files inside trace1 folder. Copy these files to your local machine and open them in VisIt (You may need to rename them so that VisIt can see them as a database). Then plot them using Pseudocolor plot. I will let you play with VisIt and figure how to create a movie from here. 

\section{The Final Task}
	It's now time for you to get your hands on some real data. Ask one of the senior members to provide you with an old case to work with. This step can only be done on Blue Waters, as the data is too big for our local machines. While the data is transferring on your BW, transfer the file \verb|abid_bot.tar.gz| file there if you have not done so. Go through the package (hint: README is a good place to start) and try to understand what's going on in different parts. Use this code to make a movie. This movie will be your certificate that you've successfully completed the tutorial.

\section{Bonus}
	\paragraph{} While the following sections are not part of the main tutorial, they are still good knowledge to have, so we have put theme together here as a bonus section. All are welcome to read through.

	\subsection{HDF5 data structure}
	This section is written with reference to the python module h5py, which can be very useful when you need to manipulate HDF5 (\cd{h5}) files. A general picture of the content of an h5 file is something like this:
	\image[HDF5 data structure summary]{0.2}{hdf5_structure.jpg}
		\subsubsection{Group}
			\par A group is somewhat analogous to a folder. A group can contain groups and other objects, or nothing. Two key differences between HDF5 groups and the conventional folder are:			

\begin{comment}

\section{Bonus: Another Dimension}
Let's redo the Final Task, but this time in 3D! Before beginning, ask a senior member to play a sample 3D movie created with VisIt.

\subsection{3D Movie exercise:}
\begin{enumerate}
\item The *.png generating process is almost identical to the previous section, and you may make the 3D movie using the same data. In \verb|run_movie_ranks.py| (found in \verb|abid_bot/bin/bw_many_folder_scripts/|), simply enable the "stereo" option in SaveWindowAttribute.
\item You may want to change the view to one that works better with 3D. The file containing the view attributes is specified in params, and you can change this to your own view .xml file. One attribute you can try changing is the eyeAngle. Hint: Open a single frame of your movie in VisIt, and change the view to your liking. Then you can export the View3DAttributes to an \verb|.xml| using the \verb|SaveAttribute()| function. See the VisIt Python Interface Manual for more details.
\item Use the abid\_bot code to generate \verb|*.png| images as before.
\item To turn your images into an mp4 movie, you will need to run two scripts: \verb|merge_3D.sh|, and then \verb|Movie_maker_3D.sh|. You can transfer your \verb|movies/| folder from Blue Waters to your computer if you'd like to run the scripts locally. Before running the scripts look them over and make neccessary changes. If you don't have the scripts ask a group member.
\item You should now have an mp4 movie. To play it, you can use the command \verb|mplayer filename|. To actually see the movie in 3D, you'll need special equipment -- ask a senior member for help. You now have a 3D movie worthy of IMAX.
\end{enumerate}
\end{comment}
\section{Final Thoughts}
Congratulations! While there are a couple of things that you will need to do, such as working with kdenlive and editing the website, those things are best taught by joining in the next time the group as a whole needs to use those tools. You should now be ready to jump right in to the group and start making science!
\end{document}
